# RIPER rules
## Overview
RIPER provides a systematic approach to software development through five distinct operational modes:

Research(R): Information gathering and understanding existing code
Innovate(I): Brainstorming potential approaches and solutions
Plan(P): Creating detailed technical specifications
Execute(E): Implementing approved plans with precision
Review(R): Validating implementation against plans

## key advantage
- single rule consumed
- no memory bank required.
- no complex project rules required
- can be used for cursor, windsurf, augment, trae, github copilot, etc.

### Source
started from cursor forum article [I created an AMAZING MODE called “RIPER-5 Mode” Fixes Claude 3.7 Drastically!](https://forum.cursor.com/t/i-created-an-amazing-mode-called-riper-5-mode-fixes-claude-3-7-drastically/65516)

## RIPER-5 01 version
You can check **[RIPER-5 01 rule](RIPER/RIPER-5-01-version.md)**

## RIPER-5 advanced version
### [RIPER-5_MULTIDIMENSIONAL_THINKING-AGENT_EXECUTION_PROTOCOL](RIPER/RIPER-5_MULTIDIMENSIONAL_THINKING-AGENT_EXECUTION_PROTOCOL.md) started from the original link in cursor forum [revised version](https://forum.cursor.com/t/i-created-an-amazing-mode-called-riper-5-mode-fixes-claude-3-7-drastically/65516/97)

### New Protocol Key Features

The new protocol (RIPER-5 + Multidimensional Thinking + Agent Execution Protocol) introduces significant enhancements over the old protocol (RIPER-5: Strict Operational Protocol).

**Automatic Mode Switching**: Eliminates explicit “ENTER [MODE]” commands, enabling seamless transitions between RESEARCH, INNOVATE, PLAN, EXECUTE, and REVIEW modes. AI intelligently selects the starting mode based on user request semantics, defaulting to RESEARCH, improving efficiency.

**Multidimensional Thinking**: Integrates systems, dialectical, innovative, and critical thinking principles across all modes, ensuring comprehensive analysis and optimized, creative solutions.

**Task File Template**: Introduces a standardized template to record task details, analysis, solutions, plans, progress, and reviews. AI dynamically updates it, ensuring full traceability.

**Code Handling Standards**: Defines unified code block structures with file paths, language identifiers, and contextual comments. Prohibits unverified dependencies or unrelated changes, enhancing code quality.

**Execution Mode Improvements**: Allows handling minor deviations (e.g., typo fixes) with prior reporting. After each step, AI updates progress, logs changes, and requests user feedback. If feedback indicates issues, it reverts to PLAN mode.

**Language and Performance**: Uses English for mode declarations and code, with Chinese for other interactions (user-configurable). Targets ≤30-second response latency, with interim updates for complex tasks.

### Improvements Over Old Protocol

The old protocol’s rigid, manual mode switching increased user effort, while its lack of thinking principles led to mechanical outputs. It had no unified task documentation, loose code standards, and inflexible execution requiring 100% plan adherence. The new protocol enhances flexibility with automatic mode switching, improves analysis with multidimensional thinking, and ensures traceability via task templates. Strict code standards and fault-tolerant execution with user feedback reduce errors. Response time targets and interim updates optimize performance, making the new protocol ideal for complex software development, balancing strictness with user-friendly intelligence.

